"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("apollo-server-env");
const graphql_1 = require("graphql");
function isStringValueNode(node) {
    return node.kind === graphql_1.Kind.STRING;
}
exports.isStringValueNode = isStringValueNode;
function isNotNullOrUndefined(value) {
    return value !== null && typeof value !== 'undefined';
}
exports.isNotNullOrUndefined = isNotNullOrUndefined;
function mapFieldNamesToServiceName(fields, serviceName) {
    return fields.reduce((prev, next) => {
        prev[next.name.value] = serviceName;
        return prev;
    }, Object.create(null));
}
exports.mapFieldNamesToServiceName = mapFieldNamesToServiceName;
function findDirectivesOnTypeOrField(node, directiveName) {
    return node && node.directives
        ? node.directives.filter(directive => directive.name.value === directiveName)
        : [];
}
exports.findDirectivesOnTypeOrField = findDirectivesOnTypeOrField;
function stripExternalFieldsFromTypeDefs(typeDefs, serviceName) {
    const strippedFields = [];
    const typeDefsWithoutExternalFields = graphql_1.visit(typeDefs, {
        ObjectTypeExtension(node) {
            let fields = node.fields;
            if (fields) {
                fields = fields.filter(field => {
                    const externalDirectives = findDirectivesOnTypeOrField(field, 'external');
                    if (externalDirectives.length > 0) {
                        strippedFields.push({
                            field,
                            parentTypeName: node.name.value,
                            serviceName,
                        });
                        return false;
                    }
                    return true;
                });
            }
            return Object.assign({}, node, { fields });
        },
    });
    return { typeDefsWithoutExternalFields, strippedFields };
}
exports.stripExternalFieldsFromTypeDefs = stripExternalFieldsFromTypeDefs;
function parseSelections(source) {
    return graphql_1.parse(`query { ${source} }`)
        .definitions[0].selectionSet.selections;
}
exports.parseSelections = parseSelections;
function hasMatchingFieldInDirectives({ directives, fieldNameToMatch, namedType, }) {
    return Boolean(namedType.astNode &&
        directives
            .map(keyDirective => keyDirective.arguments &&
            isStringValueNode(keyDirective.arguments[0].value)
            ? {
                typeName: namedType.astNode.name.value,
                keyArgument: keyDirective.arguments[0].value.value,
            }
            : null)
            .filter(isNotNullOrUndefined)
            .flatMap(selection => parseSelections(selection.keyArgument))
            .some(field => field.kind === graphql_1.Kind.FIELD && field.name.value === fieldNameToMatch));
}
exports.hasMatchingFieldInDirectives = hasMatchingFieldInDirectives;
exports.logServiceAndType = (serviceName, typeName, fieldName) => `[${serviceName}] ${typeName}${fieldName ? `.${fieldName} -> ` : ' -> '}`;
function errorWithCode(code, message) {
    return new graphql_1.GraphQLError(message, undefined, undefined, undefined, undefined, undefined, {
        code,
    });
}
exports.errorWithCode = errorWithCode;
function findTypesContainingFieldWithReturnType(schema, node) {
    if (!graphql_1.isObjectType(graphql_1.getNamedType(node.type)))
        return [];
    const returnType = graphql_1.getNamedType(node.type);
    if (!graphql_1.isObjectType(returnType))
        return [];
    const containingTypes = [];
    const types = schema.getTypeMap();
    for (const [, namedType] of Object.entries(types)) {
        if (!graphql_1.isObjectType(namedType))
            continue;
        const allFields = namedType.getFields();
        Object.values(allFields).forEach(field => {
            const fieldReturnType = graphql_1.getNamedType(field.type);
            if (fieldReturnType === returnType) {
                containingTypes.push(fieldReturnType);
            }
        });
    }
    return containingTypes;
}
exports.findTypesContainingFieldWithReturnType = findTypesContainingFieldWithReturnType;
//# sourceMappingURL=utils.js.map