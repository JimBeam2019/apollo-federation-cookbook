"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const utils_1 = require("../../utils");
exports.externalUnused = (schema) => {
    const errors = [];
    const types = schema.getTypeMap();
    for (const [typeName, namedType] of Object.entries(types)) {
        if (!graphql_1.isObjectType(namedType))
            continue;
        if (namedType.federation && namedType.federation.externals) {
            for (const [serviceName, externalFieldsForService] of Object.entries(namedType.federation.externals)) {
                for (const { field: externalField } of externalFieldsForService) {
                    const externalFieldName = externalField.name.value;
                    const allFields = namedType.getFields();
                    const hasMatchingKeyOnType = Boolean(utils_1.hasMatchingFieldInDirectives({
                        directives: utils_1.findDirectivesOnTypeOrField(namedType.astNode, 'key'),
                        fieldNameToMatch: externalFieldName,
                        namedType,
                    }));
                    const hasMatchingProvidesOrRequires = Object.values(allFields).some(maybeProvidesField => {
                        const fieldOwner = maybeProvidesField.federation &&
                            maybeProvidesField.federation.serviceName;
                        if (fieldOwner !== serviceName)
                            return false;
                        let providesDirectives = utils_1.findDirectivesOnTypeOrField(maybeProvidesField.astNode, 'provides');
                        utils_1.findTypesContainingFieldWithReturnType(schema, maybeProvidesField).map(childType => {
                            const fields = childType.getFields();
                            Object.values(fields).forEach(maybeProvidesFieldFromChildType => {
                                providesDirectives = providesDirectives.concat(utils_1.findDirectivesOnTypeOrField(maybeProvidesFieldFromChildType.astNode, 'provides'));
                            });
                        });
                        const requiresDirectives = utils_1.findDirectivesOnTypeOrField(maybeProvidesField.astNode, 'requires');
                        return (utils_1.hasMatchingFieldInDirectives({
                            directives: providesDirectives,
                            fieldNameToMatch: externalFieldName,
                            namedType,
                        }) ||
                            utils_1.hasMatchingFieldInDirectives({
                                directives: requiresDirectives,
                                fieldNameToMatch: externalFieldName,
                                namedType,
                            }));
                    });
                    if (!(hasMatchingKeyOnType || hasMatchingProvidesOrRequires)) {
                        errors.push(utils_1.errorWithCode('EXTERNAL_UNUSED', utils_1.logServiceAndType(serviceName, typeName, externalFieldName) +
                            `is marked as @external but is not used by a @requires, @key, or @provides directive.`));
                    }
                }
            }
        }
    }
    return errors;
};
//# sourceMappingURL=externalUnused.js.map